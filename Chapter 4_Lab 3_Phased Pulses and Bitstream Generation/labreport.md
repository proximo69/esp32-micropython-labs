# ðŸ§  Lab Report

## Title
**Chapter 4 â€“ Lab 3: Phased Pulses and Bitstream Generation**

**Course:** Programming the ESP32 with MicroPython  
**Author:** Michael Bradford  
**Date Performed:** 26 October 2025
**Date Submitted:** 27 October  2025 

## Abstract
This lab investigated pulse generation and timing accuracy on the ESP32 using MicroPython, with PulseView used to capture and analyze GPIO waveforms. The experiment began with a fixed-delay pulse to show how a variable workload affects pulse width. It then explored a pair of phased atomic pulses to examine timing relationships between complementary signals and revealed that software overhead can cause brief synchronization errors. A naÃ¯ve implementation using independent pin.value() calls demonstrated how such delays can create dangerous overlap conditions in real circuits. The lab concluded with hardware-based bitstream generation using the ESP32â€™s RMT peripheral, illustrating how binary data can be represented as timed voltage pulses. Overall, the results highlight the importance of precise timing control and the advantages of hardware-timed output for reliable digital communication and signal generation.

## Objective
The goal of this experiment was to analyze the switching behavior of GPIO outputs and compare timing performance between interpreted and hardware-level execution. In addition, the lab was designed to reinforce the concepts introduced in the textbook through practical, hands-on application â€” turning theoretical material into direct experience with real signals and measurement tools.


## Background / Theory

Microcontrollers control external devices by switching digital output lines (GPIO pins) between HIGH (3.3 V) and LOW (0 V) states.
When two lines are used together, as in phased pulse generation, timing becomes critical.
In software, each GPIO update requires a separate call to pin.value(), and these instructions are executed sequentially.
Even though the delay is only a few microseconds, that small lag means the two lines are never switched at exactly the same instant.

For slow applications, such as flashing LEDs, this lag is insignificant.
However, in circuits that drive motors, power switches, or push-pull transistors, any overlap where both outputs are HIGH can cause cross-conduction â€” current flowing directly from supply to ground â€” which can overheat or destroy driver components.
To avoid this, the GPIO hardware must be written atomically, so multiple pins update simultaneously.


Direct Hardware Access

To achieve simultaneous switching, MicroPython can write directly to the ESP32â€™s GPIO register instead of making separate high-level function calls.
The following function performs this operation:

def gpio_set(value, mask):
    machine.mem32[0x3FF44004] = machine.mem32[0x3FF44004] & ~mask | value & mask

Here:

machine.mem32[0x3FF44004] accesses the GPIO Output Register in the ESP32â€™s memory map.

The mask specifies which bits (pins) will be modified.
For example:

MASK = (1 << PIN_A) | (1 << PIN_B)

creates a binary pattern with 1s in the bit positions corresponding to PIN_A and PIN_B.

The value argument defines the logic levels those pins should take (1 = HIGH, 0 = LOW).

The bitwise operations & ~mask | value & mask ensure that only the selected pins are changed, leaving all others unaffected.


This approach updates both GPIO lines in one machine instruction, removing the lag between pins and producing true 180-degree phased pulses.


Bitstream Generation and RMT

Later in the lab, pulse timing was controlled using the machine.bitstream() function, which sends a sequence of precisely timed high- and low-voltage intervals representing binary data.
In this scheme:

Short pulses represent 0 bits

Long pulses represent 1 bits


The ESP32 implements this through its RMT (Remote Control) hardware peripheral.
The RMT is designed for tasks such as infrared communication, LED control, or any application requiring accurate, repetitive pulse timing.
It operates independently of the main processor, meaning pulse durations are generated by hardware rather than by the interpreter.
This provides far greater accuracy and repeatability than software loops.

While this lab used RMT in its simplest form through machine.bitstream(), the next lab will explore advanced RMT configuration for fully programmable pulse generation.


Concept Summary

Concept	                               Description

Software-timed pulses	     Easy to
                                              implement but   
                                        include instruction-                                          level delays between
                                              pin updates.

Atomic GPIO updates	   Direct hardware
                                              writes remove
                                          timing lag between
                                              multiple pins.

Bitstream generation	     Encodes binary
                                                data as timed
                                                    pulses of
                                               different widths.

RMT peripheral	         Dedicated hardware
                                                 that outputs
                                       accurate, high-speed
                                            pulse sequences
                                               without CPU
                                                involvement.


## Materials and Equipment
| Item | Description | Notes |
|------|--------------|-------|
| ESP32-WROOM Dev Board | MicroPython v1.26.1 firmware | Primary MCU |
| Logic Analyzer | HiLetGo (24 MHz) | Used with PulseView |
| Breadboard & Jumpers | Standard kit | For circuit prototyping |

## Procedure

1. Assembled the test circuit on a breadboard using the ESP32-WROOM development board, powered via USB. GPIO 18 and GPIO 19 were configured as digital outputs for the phased-pulse tests, and GPIO 21 was used for bitstream generation.
2. Connected the logic analyzer probes to the corresponding GPIO pins (CH0 â†’ GPIO 18, CH1 â†’ GPIO 19, CH2 â†’ GPIO 21) with a shared ground reference to the ESP32 GND.
3. Uploaded and executed test programs sequentially for each section: (a) fixed-delay pulse, (b) naÃ¯ve and atomic phased-pulse generation, and (c) RMT bitstream generation.
4. Captured waveforms in PulseView at a 12 MHz sample rate. Trigger and time-base settings were adjusted to display the expected pulse duration for each test (1 ms/div for fixed delay, 10 Âµs/div for phased pulses, and 5 Âµs/div for bitstream).
5. Measured and recorded pulse characteristics including high/low duration, total period, and phase relationship between outputs.
6. Compared measured values to theoretical expectations from the textbook examples to evaluate timing accuracy, synchronization, and hardware-timed precision.


## Results
Present your observations, measurements, and screenshots.

| Measurement | Expected | Observed | Difference |
|--------------|-----------|-----------|-------------|
| Pulse Width (Âµs) | 100 | 112 | +12% |
| Duty Cycle (%) | 50 | 47 | â€“3% |

**Figure 1.** Square-wave pulse captured on GPIO14 using PulseView.


Fixed Delay Pulse with Variable Workload 

    n=5
Observed: 
High Pulse: 1ms
Low Pulse: 1ms
period: 2ms
duty cycle: 50%
Expected:
High Pulse: 1ms
Low Pulse: 1ms
period: 2ms
duty cycle: 50%
Comment: 
Observed timing matched theoretical expectation

    n=5000
Observed:
High Pulse: 21ms
Low Pulse: 1ms
period: 22ms
Duty Cycle: 95.5%
Expected: 
High Pulse: Significantly higher due to high workload (n)
Low Pulse: 1ms
Period: Significantly higher than 2ms
Comment: 
Exact value unknown; expected significantly longer high pulse due to workload.

Phased (Atomic) Pulses

Observed Pulse Width: 113us
Expected Pulse Width: 100us 
Phase Difference: 180Â°
Comment: slight overhead in instruction timing. Observed phase difference matched expectations.

Naive Pulses Comparison:
Observed Pulse Lag: 100us - 150 us
Expected Pulse Lag: 100us - 150us
Phase Difference: ~150Â° - 90Â°
Comment: slight overhead in instruction timing. Phase drift observed (100â€“150 Âµs lag from software overhead).

Bitstream Generation 
Observed:
Alternating short/long pulses for 0x55
Grouped long/short pulses for 0xF0
Expected:
Alternating short/long pulses for 0x55
Grouped long/short pulses for 0xF0
Comment:
Observed alternating short/long pulses matching encoded bytes (0x55, 0xF0)

## Analysis / Discussion

The experiments in this lab demonstrated how timing accuracy and synchronization depend heavily on how GPIO outputs are controlled in MicroPython. Across all three sections â€” fixed delay pulses, phased pulse generation, and bitstream output â€” the results highlighted the limits of software-based timing and the advantages of hardware-assisted control using the ESP32â€™s peripheral features.

In the fixed-delay pulse test, the measured 1 ms high and low intervals confirmed that the ticks_us() compensation technique successfully maintained a constant period even when a variable workload was introduced. As the loop variable n increased, the high pulse widened proportionally to the processing time, producing duty cycles as high as 95 %. This demonstrated that timing consistency in interpreted code is limited by instruction execution time â€” and that, without compensation, workload length directly affects output timing.

The phased pulse experiments revealed how small delays arise when two GPIO pins are switched sequentially in software. In the naÃ¯ve implementation, the lag between rising edges ranged from 100 Âµs to 150 Âµs and varied over time. This variability, or jitter, results from MicroPythonâ€™s interpreted execution and background processes. Because the signals were not switched atomically, the phase relationship drifted continuously, meaning the two outputs were not a true 180Â° out of phase. In real hardware such as motor drivers or H-bridges, this overlap could cause cross-conduction and damage components. When the atomic gpio_set() method was used, the lag disappeared, confirming that direct register access enables true simultaneous updates and precise complementary timing.

In the final section, bitstream generation, the ESP32â€™s hardware RMT peripheral produced alternating short and long pulses corresponding to the bytes 0x55 and 0xF0. The waveform matched the expected binary patterns (short pulses for 0 bits, long pulses for 1 bits) with minimal deviation. This demonstrated the accuracy of hardware-timed output and how digital data can be encoded as pulse-width sequences. The experiment bridged the concept of GPIO timing with digital communication, showing how low-level timing control forms the foundation of serial data transfer and signal encoding.

Overall, discrepancies between measured and expected results were primarily due to timing jitter, instruction latency, and software overhead inherent to interpreted MicroPython code. Hardware variations, such as GPIO register access time and peripheral setup delay, also contributed minor deviations.

Through this lab, we learned that while MicroPython provides an accessible environment for prototyping, precise timing tasks â€” especially those requiring synchronized phase control or encoded pulse streams â€” are best handled through direct hardware access or dedicated peripherals like RMT. These experiments deepened understanding of how the ESP32 manages digital timing and why hardware-based methods are essential for reliability in fast or timing-critical systems.

## Conclusion

This lab demonstrated how timing precision and synchronization depend on the method used to control GPIO outputs in MicroPython. The fixed-delay test confirmed that ticks_us() compensation can maintain consistent pulse timing when moderate workloads are introduced, but excessive processing time still distorts pulse width and duty cycle. The naÃ¯ve phased-pulse implementation revealed measurable and variable lag between outputs caused by sequential software execution, emphasizing the need for atomic updates when generating complementary signals. The hardware-based bitstream experiment verified that the ESP32â€™s RMT peripheral can accurately produce timed pulse sequences that represent binary data.

Overall, the experiments showed that while MicroPython is well-suited for rapid development and functional testing, precise or high-speed timing applications require hardware-level control. Understanding these limitations and the value of hardware timing is essential for designing reliable embedded systems and signal-driven circuits.


---

## References
1. Fairhead, H. & James, M. *Programming the ESP32 in MicroPython*. 2023.  
2. PulseView Logic Analyzer Software, Sigrok.org.

## Appendix
Include source code listings, extra measurements, or additional photos.


Screenshots:

Bitstream Generation:

https://github.com/proximo69/esp32-micropython-labs/raw/main/Chapter%204_Lab%203_Phased%20Pulses%20and%20Bitstream%20Generation/images/Chapter%204_Lab%203_bitstream%20generation.jpg


Fixed Pulse_Variable Workload _n=5:

https://github.com/proximo69/esp32-micropython-labs/raw/main/Chapter%204_Lab%203_Phased%20Pulses%20and%20Bitstream%20Generation/images/Chapter%204_Lab%203_fixed_n%3D5.jpg


Fixed Pulse_Variable Workload _n=5000:

https://github.com/proximo69/esp32-micropython-labs/raw/main/Chapter%204_Lab%203_Phased%20Pulses%20and%20Bitstream%20Generation/images/Chapter%204_Lab%203_fixed_n%3D5000.jpg

Phased Pulses:

https://github.com/proximo69/esp32-micropython-labs/raw/main/Chapter%204_Lab%203_Phased%20Pulses%20and%20Bitstream%20Generation/images/Chapter%204_Lab%203_fixed_n%3D5000.jpg

Phased NaÃ¯ve Comparison:

https://github.com/proximo69/esp32-micropython-labs/blob/main/Chapter%204_Lab%203_Phased%20Pulses%20and%20Bitstream%20Generation/images/Phased_Naive%20Comparison.jpg
